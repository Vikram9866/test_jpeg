"""The functionality of entire Run Length Encoder is checked here"""

from myhdl import StopSimulation
from myhdl import block
from myhdl import ResetSignal, Signal, instance
from myhdl.conversion import verify

from testcases import red_pixels_1, red_pixels_2
from testcases import blue_pixels_1, blue_pixels_2
from testcases import green_pixels_1, green_pixels_2

from jpegenc.subblocks.RLE.rletop import DataStream, BufferDataBus
from jpegenc.subblocks.RLE.rletop import rletop
from jpegenc.subblocks.RLE.RLECore.rlecore import RLEConfig, Component

from common import tbclock, reset_on_start, resetonstart
from common import numofbits, start_of_block


def write_block(
        clock, block_in, input_interface, control_unit, color):
    """Write the data into RLE Double Buffer"""

    max_cnt = 2**(len(input_interface.read_addr)) - 1
    # select one among y1,y2 or cb or cr to be processes
    control_unit.color_component.next = color

    # wait till start signal asserts
    yield start_of_block(clock, control_unit.start)

    # read data into rle module
    input_interface.data_in.next = block_in[input_interface.read_addr]
    yield clock.posedge

    while input_interface.read_addr != max_cnt:
        # more reads
        #print ("asd %d" %input_interface.read_addr)
        input_interface.data_in.next = block_in[input_interface.read_addr]
        yield clock.posedge

    input_interface.data_in.next = block_in[input_interface.read_addr]

    # wait till all the inputs are written into RLE Double Fifo
    yield clock.posedge
    yield clock.posedge
    yield clock.posedge
    yield clock.posedge
    yield clock.posedge


def read_block(select, output_interface, clock):
    """Outputs the data from RLE Double Buffer"""

    # select which buffer should be in read mode
    output_interface.buffer_sel.next = select
    yield clock.posedge

    # enable read mode
    output_interface.read_enable.next = True
    yield clock.posedge

    # pop data out into the bus until fifo becomes empty
    while output_interface.fifo_empty != 1:
        print ("runlength %d size %d amplitude %d" % (
            output_interface.runlength,
            output_interface.size, output_interface.amplitude))
        yield clock.posedge

    # disable readmode
    output_interface.read_enable.next = False
    yield clock.posedge


def test_rle():
    """This block checks the functionality of the Run Length Encoder"""
    @block
    def bench_rle():
        """This bench checks the functionality of the rle module"""

        clock = Signal(bool(0))
        reset = ResetSignal(0, active=1, async=True)

        # constants for input, runlength, size width
        component = Component()

        width_data = 12
        width_addr = 6
        width_size = numofbits(width_data)
        width_runlength = 4

        # interfaces to the rle module
        # input to the rle core and start signals sent from here
        datastream = DataStream(width_data, width_addr)

        # signals generated by the rle core
        bufferdatabus = BufferDataBus(width_data, width_size, width_runlength)

        # selects the color component, manages address values
        rleconfig = RLEConfig()

        # instantiation for clock and rletop module
        inst = rletop(clock, reset, datastream, bufferdatabus, rleconfig)

        inst_clock = tbclock(clock)

        @instance
        def tbstim():
            """test cases given here"""

            # reset the stimulus before sending data in
            yield reset_on_start(clock, reset)

            # write y1 component into 1st buffer
            bufferdatabus.buffer_sel.next = False
            yield clock.posedge

            yield write_block(
                clock, red_pixels_1,
                datastream,
                rleconfig, component.y1
                )
            yield clock.posedge
            print ("============================")

            # read y1 component from 1st Buffer
            yield read_block(True, bufferdatabus, clock)

            # write y2 component into 2nd Buffer
            yield write_block(
                clock, red_pixels_2,
                datastream,
                rleconfig, component.y2
                )
            yield clock.posedge

            print ("============================")

            # read y2 component from 2nd Buffer
            yield read_block(False, bufferdatabus, clock)

            # write cb Component into 1st Buffer
            yield write_block(
                clock, green_pixels_1,
                datastream,
                rleconfig, component.cb
                )
            yield clock.posedge
            print ("=============================")

            # read cb component from 1st Buffer
            yield read_block(True, bufferdatabus, clock)

            # write cb Component into 2nd Buffer
            yield write_block(
                clock, green_pixels_2,
                datastream,
                rleconfig, component.cb
                )
            yield clock.posedge
            print ("==============================")

            # read cb component from 2nd Buffer
            yield read_block(False, bufferdatabus, clock)

            # write cr Component into 1st Buffer
            yield write_block(
                clock, blue_pixels_1,
                datastream,
                rleconfig, component.cr
                )
            yield clock.posedge
            print ("==============================")

            # read cr component from 1st Buffer
            yield read_block(True, bufferdatabus, clock)

            # write cr Component into 2nd Buffer
            yield write_block(
                clock, blue_pixels_2,
                datastream,
                rleconfig, component.cr
                )
            yield clock.posedge
            print ("==============================")

            # read cr component from 1st Buffer
            yield read_block(False, bufferdatabus, clock)

            print ("==============================")

            # end of stream when sof asserts
            yield clock.posedge
            rleconfig.sof.next = True
            yield clock.posedge

            raise StopSimulation

        return tbstim, inst_clock, inst

    instance_rle = bench_rle()
    instance_rle.config_sim(trace=True)
    instance_rle.run_sim()


def test_rle_conversion():
    """This block is used to test conversion"""

    @block
    def bench_rle_conversion():
        """This bench checks the conversion of module"""

        clock = Signal(bool(0))
        reset = ResetSignal(0, active=1, async=True)

        width_data = 12
        width_addr = 6
        width_size = numofbits(width_data)
        width_runlength = 4

        # interfaces to the rle module
        # input to the rle core and start signals sent from here
        datastream = DataStream(width_data, width_addr)
        assert isinstance(datastream, DataStream)

        # signals generated by the rle core
        bufferdatabus = BufferDataBus(width_data, width_size, width_runlength)
        assert isinstance(bufferdatabus, BufferDataBus)

        # selects the color component, manages address values
        rleconfig = RLEConfig()
        assert isinstance(rleconfig, RLEConfig)

        inst = rletop(clock, reset, datastream, bufferdatabus, rleconfig)

        inst_clock = tbclock(clock)
        inst_reset = resetonstart(clock, reset)

        @instance
        def tbstim():
            """dummy testcases for conversion purpose"""

            yield clock.posedge
            print ("Conversion done!!")
            raise StopSimulation

        return tbstim, inst, inst_clock, inst_reset

    verify.simulator = 'iverilog'
    assert bench_rle_conversion().verify_convert() == 0
test_rle()
