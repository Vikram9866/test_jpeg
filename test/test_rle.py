"""The functionality of entire Run Length Encoder is checked here"""

<<<<<<< HEAD
=======
# @todo: this is temporary until `rle` parameters are updated
from argparse import Namespace as Constants

>>>>>>> upstream/master
from myhdl import StopSimulation
from myhdl import block
from myhdl import ResetSignal, Signal, instance
from myhdl.conversion import verify
<<<<<<< HEAD
from testcases import *

from jpegenc.subblocks.RLE.rletop import InDataStream, BufferDataBus
from jpegenc.subblocks.RLE.rletop import rletop
from jpegenc.subblocks.RLE.RLECore.rlecore import RLEConfig, Pixel

from common import tbclock, reset_on_start, resetonstart, Constants
from common import numofbits, start_of_block, BufferConstants
=======

from jpegenc.subblocks.rle import rlencoder, InDataStream, BufferDataBus
from jpegenc.subblocks.rle import RLEConfig, Pixel

from jpegenc.testing import clock_driver, reset_on_start, pulse_reset, toggle_signal
from jpegenc.testing import run_testbench

# from testcases import *
from rle_test_inputs import (red_pixels_1, green_pixels_1, blue_pixels_1,
                             red_pixels_2, green_pixels_2, blue_pixels_2,)
>>>>>>> upstream/master


def write_block(clock, block, datastream, rleconfig, color):
    """Write the data into RLE Double Buffer"""

    # select one among Y1,Y2 or Cb or Cr to be processes
    rleconfig.color_component.next = color

    # wait till start signal asserts
<<<<<<< HEAD
    yield start_of_block(clock, datastream.start)
=======
    yield toggle_signal(datastream.start, clock)
>>>>>>> upstream/master

    # read data into rle module
    datastream.input_val.next = block[rleconfig.read_addr]
    yield clock.posedge

    while rleconfig.read_addr != 63:
        # more reads
        datastream.input_val.next = block[rleconfig.read_addr]
        yield clock.posedge

    datastream.input_val.next = block[rleconfig.read_addr]

    # wait till all the inputs are written into RLE Double Fifo
<<<<<<< HEAD
    yield clock.posedge
    yield clock.posedge
    yield clock.posedge
    yield clock.posedge
    yield clock.posedge
=======
    for _ in range(4):
        yield clock.posedge
>>>>>>> upstream/master


def read_block(select, bufferdatabus, clock):
    """Outputs the data from RLE Double Buffer"""

    # select which buffer should be in read mode
    bufferdatabus.buffer_sel.next = select
    yield clock.posedge

    # enable read mode
    bufferdatabus.read_enable.next = True
    yield clock.posedge

    # pop data out into the bus until fifo becomes empty
    while bufferdatabus.fifo_empty != 1:
<<<<<<< HEAD
        print ("runlength %d size %d amplitude %d" % (
=======
        print("runlength %d size %d amplitude %d" % (
>>>>>>> upstream/master
            bufferdatabus.runlength,
            bufferdatabus.size, bufferdatabus.amplitude))
        yield clock.posedge

<<<<<<< HEAD
    print ("runlength %d size %d amplitude %d" % (
=======
    print("runlength %d size %d amplitude %d" % (
>>>>>>> upstream/master
        bufferdatabus.runlength, bufferdatabus.size, bufferdatabus.amplitude))

    # disable readmode
    bufferdatabus.read_enable.next = False
    yield clock.posedge


def test_rle():
<<<<<<< HEAD
    """This block checks the functionality of the Run Length Encoder"""
=======
    """This test checks the functionality of the Run Length Encoder"""
>>>>>>> upstream/master
    @block
    def bench_rle():

        clock = Signal(bool(0))
        reset = ResetSignal(0, active=1, async=True)

        # constants for input, runlength, size width
<<<<<<< HEAD
        constants = Constants(6, 12, 63, 4)
=======
        width = 6
        constants = Constants(width_addr=width, width_data=12,
                              max_write_cnt=63, rlength=4,
                              size=width.bit_length())
>>>>>>> upstream/master
        pixel = Pixel()

        # interfaces to the rle module
        # input to the rle core and start signals sent from here
        indatastream = InDataStream(constants.width_data)

        # signals generated by the rle core
        bufferdatabus = BufferDataBus(
            constants.width_data, constants.size, constants.rlength)

        # selects the color component, manages address values
<<<<<<< HEAD
        rleconfig = RLEConfig(numofbits(constants.max_write_cnt))

        # rle double buffer constants
        width_dbuf = constants.width_data + constants.size + constants.rlength
        dfifo_const = BufferConstants(width_dbuf, constants.max_write_cnt + 1)

        # instantiation for clock and rletop module
        inst = rletop(
            dfifo_const, constants, reset, clock,
            indatastream, bufferdatabus, rleconfig)

        inst_clock = tbclock(clock)
=======
        rleconfig = RLEConfig(constants.max_write_cnt.bit_length())

        # rle double buffer constants
        width_dbuf = constants.width_data + constants.size + constants.rlength
        dfifo_const = Constants(width=width_dbuf, depth=constants.max_write_cnt + 1)

        # instantiation for clock and rletop module
        inst = rlencoder(
            dfifo_const, constants, reset, clock,
            indatastream, bufferdatabus, rleconfig
        )

        inst_clock = clock_driver(clock)
>>>>>>> upstream/master

        @instance
        def tbstim():

            # reset the stimulus before sending data in
<<<<<<< HEAD
            yield reset_on_start(clock, reset)
=======
            yield pulse_reset(reset, clock)
>>>>>>> upstream/master

            # write Y1 component into 1st buffer
            bufferdatabus.buffer_sel.next = False
            yield clock.posedge
            yield write_block(
                clock, red_pixels_1,
                indatastream,
                rleconfig, pixel.Y1
                )
            yield clock.posedge
<<<<<<< HEAD
            print ("============================")
=======
            print("============================")
>>>>>>> upstream/master

            # read Y1 component from 1st Buffer
            yield read_block(True, bufferdatabus, clock)

            # write Y2 component into 2nd Buffer
            yield write_block(
                clock, red_pixels_2,
                indatastream,
                rleconfig, pixel.Y2
                )
            yield clock.posedge

<<<<<<< HEAD
            print ("============================")
=======
            print("============================")
>>>>>>> upstream/master

            # read Y2 component from 2nd Buffer
            yield read_block(False, bufferdatabus, clock)

            # write Cb Component into 1st Buffer
            yield write_block(
                clock, green_pixels_1,
                indatastream,
                rleconfig, pixel.Cb
                )
            yield clock.posedge
<<<<<<< HEAD
            print ("=============================")
=======
            print("=============================")
>>>>>>> upstream/master

            # read Cb component from 1st Buffer
            yield read_block(True, bufferdatabus, clock)

            # write Cb Component into 2nd Buffer
            yield write_block(
                clock, green_pixels_2,
                indatastream,
                rleconfig, pixel.Cb
                )
            yield clock.posedge
<<<<<<< HEAD
            print ("==============================")
=======
            print("==============================")
>>>>>>> upstream/master

            # read Cb component from 2nd Buffer
            yield read_block(False, bufferdatabus, clock)

            # write Cr Component into 1st Buffer
            yield write_block(
                clock, blue_pixels_1,
                indatastream,
                rleconfig, pixel.Cr
                )
            yield clock.posedge
<<<<<<< HEAD
            print ("==============================")
=======
            print("==============================")
>>>>>>> upstream/master

            # read Cr component from 1st Buffer
            yield read_block(True, bufferdatabus, clock)

            # write Cr Component into 2nd Buffer
            yield write_block(
                clock, blue_pixels_2,
                indatastream,
                rleconfig, pixel.Cr
                )
            yield clock.posedge
<<<<<<< HEAD
            print ("==============================")
=======
            print("==============================")
>>>>>>> upstream/master

            # read Cr component from 1st Buffer
            yield read_block(False, bufferdatabus, clock)

<<<<<<< HEAD
            print ("==============================")
=======
            print("==============================")
>>>>>>> upstream/master

            # end of stream when sof asserts
            yield clock.posedge
            rleconfig.sof.next = True
            yield clock.posedge

            raise StopSimulation

        return tbstim, inst_clock, inst

<<<<<<< HEAD
    instance_rle = bench_rle()
    instance_rle.config_sim(trace=True)
    instance_rle.run_sim()
=======
    run_testbench(bench_rle)
>>>>>>> upstream/master


def test_rle_conversion():
    """This block is used to test conversion"""

    @block
    def bench_rle_conversion():

<<<<<<< HEAD
        constants = Constants(6, 12, 63, 4)
=======
        width = 6
        constants = Constants(width_addr=width, width_data=12,
                              max_write_cnt=63, rlength=4,
                              size=width.bit_length())
>>>>>>> upstream/master

        clock = Signal(bool(0))
        reset = ResetSignal(0, active=1, async=True)

        indatastream = InDataStream(constants.width_data)
        bufferdatabus = BufferDataBus(
            constants.width_data, constants.size, constants.rlength)

<<<<<<< HEAD
        rleconfig = RLEConfig(numofbits(constants.max_write_cnt))

        width_dbuf = constants.width_data + constants.size + constants.rlength
        dfifo_const = BufferConstants(width_dbuf, constants.max_write_cnt + 1)

        inst = rletop(
            dfifo_const, constants, reset,
            clock, indatastream, bufferdatabus, rleconfig)

        inst_clock = tbclock(clock)
        inst_reset = resetonstart(clock, reset)
=======
        rleconfig = RLEConfig(constants.max_write_cnt.bit_length())

        width_dbuf = constants.width_data + constants.size + constants.rlength
        dfifo_const = Constants(width=width_dbuf, depth=constants.max_write_cnt + 1)

        inst = rlencoder(
            dfifo_const, constants, reset, clock,
            indatastream, bufferdatabus, rleconfig)

        inst_clock = clock_driver(clock)
        inst_reset = reset_on_start(reset, clock)
>>>>>>> upstream/master

        @instance
        def tbstim():
            yield clock.posedge
<<<<<<< HEAD
            print ("Conversion done!!")
=======
            print("Conversion done!!")
>>>>>>> upstream/master
            raise StopSimulation

        return tbstim, inst, inst_clock, inst_reset

    verify.simulator = 'iverilog'
    assert bench_rle_conversion().verify_convert() == 0
<<<<<<< HEAD
=======


if __name__ == "__main__":
    test_rle()
>>>>>>> upstream/master
