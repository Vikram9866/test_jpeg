"""The above testbench tests rle functioning and conversion"""

from myhdl import StopSimulation
from myhdl import block
from myhdl import ResetSignal, Signal, instance
from myhdl.conversion import verify

from jpegenc.subblocks.RLE.RLECore.rlecore import DataStream, rle, Component
from jpegenc.subblocks.RLE.RLECore.rlecore import RLESymbols, RLEConfig

from testcases import red_pixels_1, red_pixels_2
from testcases import blue_pixels_1, blue_pixels_2
from testcases import green_pixels_1, green_pixels_2

from common import tbclock, reset_on_start, resetonstart
from common import numofbits, start_of_block


def block_process(
        clock, block_in, input_interface,
        output_interface, control_unit, color, max_count):
    """This block sends data into rlecore and prints the output"""

    assert isinstance(input_interface, DataStream)
    assert isinstance(output_interface, RLESymbols)
    assert isinstance(control_unit, RLEConfig)

    # select one among y1,y2 or cb or cr to be processes
    control_unit.color_component.next = color

    # wait till start signal asserts
    yield start_of_block(clock, control_unit.start)

    # read input from the block
    input_interface.data_in.next = block_in[input_interface.read_addr]
    yield clock.posedge

    # read more inputs
    while input_interface.read_addr != max_count:
        input_interface.data_in.next = block_in[input_interface.read_addr]
        yield clock.posedge

        # print output
        if output_interface.dovalid:
            print("amplitude = %d runlength = %d size = %d" % (
                output_interface.amplitude,
                output_interface.runlength, output_interface.size))

    input_interface.data_in.next = block_in[input_interface.read_addr]

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))

    # extra clocks for all the inputs to process

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))

    yield clock.posedge


def test_rle_core():
    """We check the functionality here"""

    clock = Signal(bool(0))
    reset = ResetSignal(0, active=1, async=True)

    # constants for input, runlength, size width
    component = Component()

    # interfaces to the rle core
    # input to the rle core and start signals sent from here
    width_data = 12
    width_addr = 6
    width_size = numofbits(width_data)
    max_addr_cnt = (2**(width_addr)) - 1
    width_runlength = 4

    datastream = DataStream(width_data, width_addr)
    assert isinstance(datastream, DataStream)

    # signals generated by the rle core
    rlesymbols = RLESymbols(width_data, width_size, width_runlength)
    assert isinstance(rlesymbols, RLESymbols)

    # selects the color component, manages address values
    rleconfig = RLEConfig()
    assert isinstance(rleconfig, RLEConfig)

    @block
    def bench_rle_core():
        """The RLE Core is tested in this block"""

        # instantiation of the rle core
        inst = rle(
            clock, reset, datastream, rlesymbols, rleconfig
            )

        # clock instantiation
        inst_clock = tbclock(clock)

        @instance
        def tbstim():
            """Test inputs given here"""

            # reset before sending data
            yield reset_on_start(clock, reset)

            # components of type y1 or y2 processed
            yield block_process(
                clock, red_pixels_1,
                datastream,
                rlesymbols,
                rleconfig, component.y1, max_addr_cnt
                )

            print ("======================")

            # components of type y1 or y2 processed
            yield block_process(
                clock, red_pixels_2,
                datastream,
                rlesymbols,
                rleconfig, component.y2, max_addr_cnt
                )

            print ("=====================")

            # components of type cb processes
            yield block_process(
                clock, green_pixels_1,
                datastream,
                rlesymbols,
                rleconfig, component.cb, max_addr_cnt
                )

            print ("=====================")

            # components od type cb processed
            yield block_process(
                clock, green_pixels_2,
                datastream,
                rlesymbols,
                rleconfig, component.cb, max_addr_cnt
                )

            print ("=====================")

            # components of type cr processed
            yield block_process(
                clock, blue_pixels_1,
                datastream,
                rlesymbols,
                rleconfig, component.cr, max_addr_cnt
                )

            print ("=====================")

            # components of type cr processed
            yield block_process(
                clock, blue_pixels_2,
                datastream,
                rlesymbols,
                rleconfig, component.cr, max_addr_cnt
                )

            print ("=====================")

            # end of stream when sof asserts
            rleconfig.sof.next = True
            yield clock.posedge

            raise StopSimulation

        return tbstim, inst_clock, inst

    instance_rle = bench_rle_core()
    instance_rle.config_sim(trace=True)
    instance_rle.run_sim()


def test_rle_conversion():
    """This module checks for conversion"""
    clock = Signal(bool(0))
    reset = ResetSignal(0, active=1, async=True)

    width_data = 12
    width_addr = 6
    width_size = numofbits(width_data)

    width_runlength = 4

    datastream = DataStream(width_data, width_addr)
    assert isinstance(datastream, DataStream)

    # signals generated by the rle core
    rlesymbols = RLESymbols(width_data, width_size, width_runlength)
    assert isinstance(rlesymbols, RLESymbols)

    # selects the color component, manages address values
    rleconfig = RLEConfig()
    assert isinstance(rleconfig, RLEConfig)

    @block
    def bench_rle_core():
        """The conversion module for rle core"""
        inst = rle(
            clock, reset,
            datastream, rlesymbols, rleconfig
            )

        inst_clock = tbclock(clock)
        inst_reset = resetonstart(clock, reset)

        @instance
        def tbstim():
            """dummy inputs for conversion purpose"""
            yield clock.posedge
            print ("Conversion done!!")
            raise StopSimulation

        return tbstim, inst, inst_clock, inst_reset

    verify.simulator = 'iverilog'
    assert bench_rle_core().verify_convert() == 0
test_rle_core()
